globals[
  total-amount-of-transaction-for-this-tick
] 

to update-economy-variables
  set total-amount-of-transaction-for-this-tick 0
end

to perform-trades-between-gathering-points
  
  let total-amount-of-goods-available-in-workplaces sum [stock-of-goods] of gathering-points with [gathering-type = "workplace"]
  let virtual-total-amount-of-goods-available-in-workplaces total-amount-of-goods-available-in-workplaces
  let virtual-total-amount-of-goods-available-in-workplaces-converted-to-capital virtual-total-amount-of-goods-available-in-workplaces * unit-price-of-goods
  let actual-amount-of-stocks-bought 0
  
  ;essential-shop
  let total-capital-available-in-essential-shops-to-buy-goods 0
  ask essential-shops
  [
    let capital-available-to-buy-goods amount-of-capital - max-amount-of-capital-to-retain
    set capital-available-to-buy-goods max (list capital-available-to-buy-goods 0)
    set total-capital-available-in-essential-shops-to-buy-goods total-capital-available-in-essential-shops-to-buy-goods + capital-available-to-buy-goods
  ]
  
  let total-capital-to-be-spent-by-essential-shops min (list total-capital-available-in-essential-shops-to-buy-goods virtual-total-amount-of-goods-available-in-workplaces-converted-to-capital)
  
  if total-capital-to-be-spent-by-essential-shops > 0
  [
    ;;Gustavo: ok, this should work. Maybe it would be best to have an external function for transations i.e. "I buy X goods from Y, I lose X' money, he gets X' money"
    ;;it is more in line with the agent-oriented paradigm (and makes it easier to track transactions for instance)
    ;;same for other places
    ask essential-shops
    [
      let capital-available-to-buy-goods amount-of-capital - max-amount-of-capital-to-retain
      set capital-available-to-buy-goods max (list capital-available-to-buy-goods 0)
      
      let amount-charged capital-available-to-buy-goods / total-capital-available-in-essential-shops-to-buy-goods * total-capital-to-be-spent-by-essential-shops
      let stock-bought (floor amount-charged / unit-price-of-goods)
      set stock-bought min (list (max-stock-of-goods-in-a-shop - stock-of-goods) stock-bought)
      set amount-charged stock-bought * unit-price-of-goods
      
      set amount-of-capital amount-of-capital - amount-charged
      set current-profit current-profit - amount-charged
      set stock-of-goods stock-of-goods + stock-bought
      set actual-amount-of-stocks-bought actual-amount-of-stocks-bought + stock-bought
      
      set total-amount-of-transaction-for-this-tick total-amount-of-transaction-for-this-tick + amount-of-capital
    ]
  ]
  
  ;updating "virtual" amount of goods available in workplaces
  set virtual-total-amount-of-goods-available-in-workplaces virtual-total-amount-of-goods-available-in-workplaces - actual-amount-of-stocks-bought
  set virtual-total-amount-of-goods-available-in-workplaces-converted-to-capital virtual-total-amount-of-goods-available-in-workplaces * unit-price-of-goods
  
  ;non-essential-shop
  let total-capital-available-in-non-essential-shops-to-buy-goods 0
  ask non-essential-shops
  [
    let capital-available-to-buy-goods amount-of-capital - max-amount-of-capital-to-retain
    set capital-available-to-buy-goods max (list capital-available-to-buy-goods 0)
    set total-capital-available-in-non-essential-shops-to-buy-goods total-capital-available-in-non-essential-shops-to-buy-goods + capital-available-to-buy-goods
  ]
  
  let total-capital-to-be-spent-by-non-essential-shops min (list total-capital-available-in-non-essential-shops-to-buy-goods virtual-total-amount-of-goods-available-in-workplaces-converted-to-capital)
  
  ;;might be a very good idea to refactor this, make it agent based, use the same function as for essential shops
  ;;i.e. having a function perform-buyout non-essential-shops
  if total-capital-to-be-spent-by-non-essential-shops > 0
  [
    ask non-essential-shops
    [
      let capital-available-to-buy-goods amount-of-capital - max-amount-of-capital-to-retain
      set capital-available-to-buy-goods max (list capital-available-to-buy-goods 0)
      let amount-charged capital-available-to-buy-goods / total-capital-available-in-non-essential-shops-to-buy-goods * total-capital-to-be-spent-by-non-essential-shops
      
      let stock-bought (floor amount-charged / unit-price-of-goods)
      set stock-bought min (list (max-stock-of-goods-in-a-shop - stock-of-goods) stock-bought)
      set amount-charged stock-bought * unit-price-of-goods
      
      set amount-of-capital amount-of-capital - amount-charged
      set current-profit current-profit - amount-charged
      set stock-of-goods stock-of-goods + stock-bought
      set actual-amount-of-stocks-bought actual-amount-of-stocks-bought + stock-bought
      
      set total-amount-of-transaction-for-this-tick total-amount-of-transaction-for-this-tick + amount-of-capital
    ]
  ]
  
  ;workplace
  let total-capital-spent-by-all-shops actual-amount-of-stocks-bought * unit-price-of-goods
  
  if total-capital-spent-by-all-shops > 0
  [
    ask gathering-points with [gathering-type = "workplace"]
    [
      let capital-income stock-of-goods / total-amount-of-goods-available-in-workplaces * total-capital-spent-by-all-shops
      set amount-of-capital amount-of-capital + capital-income
      set current-profit current-profit + capital-income
      set stock-of-goods stock-of-goods - capital-income / unit-price-of-goods
    ]
  ]
end

to-report is-salary-value? [v]
  report first v = "salary"
end

to-report is-work-value? [v]
  report first v = "work"
end

to-report is-purchase-value? [v]
  report first v = "purchase"
end

to-report is-subsidy-value? [v]
  report first v = "subsidy"
end

to-report is-payment-value? [v]
  report first v = "payment"
end

to-report is-tax-value? [v]
  report first v = "tax"
end

to-report salary-value-from [v]
  report last v
end

to-report is-government? [v]
  report v = "government"
end

to-report is-nothing? [v]
  report first v = "nothing"
end

to increase-capital-by [val]
  
  if is-person? self
  [
    set my-amount-of-capital my-amount-of-capital + val
    set my-current-income my-current-income + val
  ]
  
  if is-gathering-point? self
  [
    set amount-of-capital amount-of-capital + val
    set current-profit current-profit + val
  ]
end

to perform-cash-transfer [a1 a2 amount]
  ;from a1 to a2
  
  ifelse is-government? a1
  [
    set government-reserve-of-capital government-reserve-of-capital - amount
    ask a2 [increase-capital-by amount]
  ]
  [
    ifelse is-government? a2
    [
      ask a1 [increase-capital-by (- amount)]
      set government-reserve-of-capital government-reserve-of-capital + amount
    ]
    [
      ask a1 [increase-capital-by (- amount)]
      ask a2 [increase-capital-by amount]
    ]
  ]
  
  set total-amount-of-transaction-for-this-tick total-amount-of-transaction-for-this-tick + abs amount
end

to-report is-cash-transfer? [value]
  if value = "work" [report false]
  if is-work-value? value [report false]
  if is-purchase-value? value [report false]
  if is-nothing? value [report false]
  if is-salary-value? value [report true]
  if is-subsidy-value? value [report true]
  if is-payment-value? value [report true]
  if is-tax-value? value [report true]
  error (sentence "unimplemented for:" value)
end

to-report cash-value-of [v]
  report last v
end

to-report purchase-amount-of [v]
  report last v
end

to perform-transaction [a1 a2 value-a2-to-a1 value-a1-to-a2]

  let a2-to-a1-completed? false
  let a1-to-a2-completed? false
  
  
;        set amount-earned amount-earned + worker-subsidy
;        set government-reserve-of-capital government-reserve-of-capital - worker-subsidy
  
  if is-cash-transfer? value-a1-to-a2
  [
    perform-cash-transfer a1 a2 (cash-value-of value-a1-to-a2)
    set a1-to-a2-completed? true
  ]
  
  if is-cash-transfer? value-a2-to-a1
  [
    perform-cash-transfer a2 a1 (cash-value-of value-a2-to-a1)
    set a2-to-a1-completed? true
  ]
  
  ;;work performance could be related to another part of the model; but let's save it here for now & simplicity
  if is-work-value? value-a1-to-a2
  [
    if is-person? a1 and is-gathering-point? a2
    [
      if [is-workplace?] of a2
      [
        ask a2 [set stock-of-goods stock-of-goods + goods-produced-by-work-performed]
      ]
      set a1-to-a2-completed? true
    ]
  ]
  
  if is-work-value? value-a2-to-a1
  [
    if is-person? a2 and is-gathering-point? a1
    [
      if [is-workplace?] of a1
      [
        ask a1 [set stock-of-goods stock-of-goods + goods-produced-by-work-performed]
      ]
      set a2-to-a1-completed? true
    ]
  ]
  
  if is-purchase-value? value-a1-to-a2
  [
    let purchase-amount purchase-amount-of value-a1-to-a2
    if is-person? a2 and is-gathering-point? a1
    [
      ask a1 [set stock-of-goods stock-of-goods - purchase-amount]
      if [is-essential-shop?] of a1
      [
        ask a2 [ask my-home [set available-food-rations available-food-rations + purchase-amount]]
      ]
      set a1-to-a2-completed? true
    ]
  ]
  
  if is-purchase-value? value-a2-to-a1
  [
    let purchase-amount purchase-amount-of value-a2-to-a1
    if is-person? a1 and is-gathering-point? a2
    [
      ask a2 [set stock-of-goods stock-of-goods - purchase-amount]
      if [is-essential-shop?] of a2
      [
        ask a1 [ask my-home [set available-food-rations available-food-rations + purchase-amount]]
      ]
      set a2-to-a1-completed? true
    ]
  ]
  
  if is-nothing? value-a1-to-a2 [set a1-to-a2-completed? true]
  if is-nothing? value-a2-to-a1 [set a2-to-a1-completed? true]
  
  if a1-to-a2-completed? and a2-to-a1-completed? [stop]
  
  if is-gathering-point? a2 [show [gathering-type] of a2]
  error (sentence "not implemented" a1 a2 value-a2-to-a1 value-a1-to-a2)
  
;  ;
;      [
;        ifelse [gathering-type] of current-activity = "workplace"
;        [
;          set amount-to-earn 10
;          let picked-workplace max-one-of all-workplaces [amount-of-capital]
;          set amount-earned min (list amount-to-earn max (list [amount-of-capital] of picked-workplace 0))
;          ask picked-workplace [set amount-of-capital amount-of-capital - amount-earned set current-profit current-profit - amount-earned set stock-of-goods stock-of-goods + contribution-to-stock]
;        ]
;        [
;          ifelse [gathering-type] of current-activity = "school"
;          [
;            set amount-to-earn 10
;            let picked-school max-one-of all-schools [amount-of-capital]
;            set amount-earned min (list amount-to-earn max (list [amount-of-capital] of picked-school 0))
;            ask picked-school [set amount-of-capital amount-of-capital - amount-earned set current-profit current-profit - amount-earned]
;          ]
;          [
;            error (sentence "not implemented" [gathering-type] of current-activity)
;          ]
;        ]
;      ]
;    ]
  
end

to perform-government-actions
  ;collect taxes
  let taxes-collected 0

  ask gathering-points with [gathering-type = "essential-shop"]
  [
    if current-profit > 0
    [
      let tax-amount current-profit * ratio-tax-on-essential-shops
      set taxes-collected taxes-collected + tax-amount
      
      perform-transaction "government" self (list "tax" tax-amount) (list "nothing")
    ]
  ]

  ask gathering-points with [gathering-type = "non-essential-shop"]
  [
    if current-profit > 0
    [
      let tax-amount current-profit * ratio-tax-on-non-essential-shops
      set taxes-collected taxes-collected + tax-amount
      
      perform-transaction "government" self (list "tax" tax-amount) (list "nothing")
    ]
  ]

  ask gathering-points with [gathering-type = "workplace"]
  [
    if current-profit > 0
    [
      let tax-amount current-profit * ratio-tax-on-workplaces
      set taxes-collected taxes-collected + tax-amount
      
      perform-transaction "government" self (list "tax" tax-amount) (list "nothing")
    ]
  ]

  ask people with [age = "worker"]
  [
    if my-current-income > 0
    [
      let tax-amount my-current-income * ratio-tax-on-workers
      set taxes-collected taxes-collected + tax-amount
      
      perform-transaction "government" self (list "tax" tax-amount) (list "nothing")
    ]
  ]

  ;redistribution
  let school-subsidy taxes-collected * ratio-school-subsidy
  let hospital-subsidy taxes-collected * ratio-hospital-subsidy
  let university-subsidy taxes-collected * ratio-university-subsidy
  let retirees-subsidy taxes-collected * ratio-retirees-subsidy
  let students-subsidy taxes-collected * ratio-students-subsidy
  
  let n-of-schools count gathering-points with [gathering-type = "school"]
  ask gathering-points with [gathering-type = "school"]
  [
    let subsidy school-subsidy / n-of-schools
    
    perform-transaction self "government" (list "subsidy" subsidy) (list "nothing")
  ]

  let n-of-hospitals count gathering-points with [gathering-type = "hospital"]
  ask gathering-points with [gathering-type = "hospital"]
  [
    let subsidy hospital-subsidy / n-of-hospitals
    
    perform-transaction self "government" (list "subsidy" subsidy) (list "nothing")
  ]

  let n-of-universities count gathering-points with [gathering-type = "university"]
  ask gathering-points with [gathering-type = "university"]
  [
    let subsidy university-subsidy / n-of-universities
    
    perform-transaction self "government" (list "subsidy" subsidy) (list "nothing")
  ]

  let n-of-retirees count people with [age = "retired"]
  ask people with [age = "retired"]
  [
    let subsidy retirees-subsidy / n-of-retirees
    
    perform-transaction self "government" (list "subsidy" subsidy) (list "nothing")
  ]

  let n-of-students count people with [age = "student"]
  ask people with [age = "student"]
  [
    let subsidy students-subsidy / n-of-students
    
    perform-transaction self "government" (list "subsidy" subsidy) (list "nothing")
  ]
end

to-report total-capital
  report sum [my-amount-of-capital] of people + sum [amount-of-capital] of gathering-points
end